#include<stdio.h> 
#define MAX_Vertices 20 
#define MAX_Length 20 
#define MAX_Element 40 
typedef struct{ 
    int A[MAX_Vertices][MAX_Vertices]; 
int n; 
}Graph; 
void init_Graph(Graph *G, int n){ 
G->n=n; 
int i, j; 
for(i=1; i<=G->n; i++) 
for(j=1; j<=G->n; j++) 
G->A[i][j] = 0; 
} 
void print_Graph(Graph G){ 
int i, j; 
for(i=1; i<=G.n; i++){ 
for(j=1; j<=G.n; j++) 
printf("%d ", G.A[i][j]); 
printf("\n"); 
    }  
    printf("\n"); 
} 
void add_edge(Graph *G, int x, int y){ 
G->A[x][y] =1; 
G->A[y][x] =1; 
} 
int adjacent(Graph *G, int x, int y){ 
return(G->A[x][y] !=0 ); 
} 
int degree(Graph *G, int x){ 
int i, deg=0; 
for(i=1; i<=G->n; i++){ 
if(adjacent(G, i, x)) deg++; 
} 
return deg; 
} 
typedef struct{ 
int data[MAX_Length]; 
int size; 
}List; 
void make_null(List *list){ 
list->size=0; 
} 
void push_back(List *list, int x){ 
list->data[list->size] =x; 
list->size++; 
} 
int element_at(List *list, int i){ 
return list->data[i-1]; 
} 
List neighbors(Graph *G, int x){ 
List L; 
make_null(&L); 
int i; 
for(i=1; i<=G->n; i++) 
if(adjacent(G, i, x)) push_back(&L, i);	 
return L; 
} 
typedef struct { 
int data[MAX_Element]; 
int front, rear; 
}Queue; 
void make_null_queue(Queue *Q){ 
Q->front =0; 
Q->rear =-1; 
} 
int empty(Queue *Q){ 
return Q->front > Q->rear; 
} 
void push(Queue *Q, int x){ 
Q->rear++; 
Q->data[Q->rear] =x; 
} 
int top(Queue *Q){ 
return Q->data[Q->front]; 
} 
void pop(Queue *Q){ 
Q->front++; 
} 
int mark[MAX_Vertices]; 
void breath_first_search(Graph *G, int k){ 
Queue frontier; 
make_null_queue(&frontier); 
int i;  
push(&frontier, k); 
mark[k] =1; 
while(!empty(&frontier)){ 
int x = top(&frontier); 
pop(&frontier); 
printf("%d\n", x); 
List list = neighbors(G, x); 
for(i=1; i<=list.size; i++){ 
int y = element_at(&list, i); 
if(mark[y] ==0){ 
mark[y] =1; 
push(&frontier, y); 
} 
} 
}
} 
int main(){ 
Graph G;	 
int n, m; 
//	freopen("DFS_Recursion.txt", "r", stdin); 
scanf("%d%d", &n, &m); 
init_Graph(&G, n); 
int u, v, i; 
for(i=1; i<=m; i++){ 
scanf("%d%d", &u, &v); 
add_edge(&G, u, v); 
} 
for(i=1; i<=G.n; i++) mark[i] =0; 
for(i=1; i<=n; i++) 
if(mark[i] ==0) 
breath_first_search(&G, i);							 
return 0; 
} 

======
#include <stdio.h>
#define MAX_ELEMENTS 100
#define MAX_VERTICES 100
typedef int Element_Type;
typedef struct {
Element_Type data[MAX_ELEMENTS];
int size;
}List;
void make_null_list(List *L){
L->size=0;
}
void push_back(List *L, Element_Type x){
L->data[L->size]=x;
L->size++;
}
Element_Type element_at(List *L, int i){
return L->data[i-1];
}
int count_list(List *L){
return L->size;
}
typedef struct {
int n;
List adj[MAX_VERTICES];
}Graph;
void init_graph(Graph *G, int n){
G->n=n;
int i;
for(i=1; i<=n; i++)
make_null_list(&G->adj[i]);
}
void add_edge(Graph *G, int x, int y){
push_back(&G->adj[x], y);
push_back(&G->adj[y], x);
}
int adjacent(Graph *G, int x, int y){
int i;
for(i=1; i<=G->adj[x].size; i++)
if(element_at(&G->adj[x],i) == y)
return 1;
return 0;
}
int degree(Graph *G, int x){
return G->adj[x].size;
}
List neighbors(Graph *G, int x){
List L;
make_null_list(&L);
int y;
for(y=1 ;y<=G->n; y++)
if(adjacent(G,x,y) ) push_back(&L, y);
return L;
}
int mark[MAX_VERTICES];
void traversal(Graph *G, int x){
if(mark[x] == 1) return;
mark[x]=1;
printf("%d\n",x);
List L=neighbors(G,x);
int i;
for(i=1; i<=L.size; i++){
int y=element_at(&L,i);
traversal(G,y);
}
}
void depth_first_search(Graph *G, int x){
int i;
for(i=1; i<=G->n; i++)
//mark[i]=0;
traversal(G,x);
}
int main(){
// freopen("dt.txt", "r", stdin);
Graph G;
int n, m, u, v, w, e;
scanf("%d%d", &n, &m);
init_graph(&G, n);
for (e = 0; e < m; e++) {
scanf("%d%d", &u, &v);
add_edge(&G, u, v);
}
depth_first_search(&G, 1);
for (w = 1; w <= n; w++)
if (mark[w] == 0)
depth_first_search(&G,w);
}

======================================

#include<stdio.h>
#define MAX_LENGTH 100
#define MAX_VERTICES 100
#define MAX_EDGES 500
typedef struct{
int u,v,w;
}Edge;
typedef struct{
int n,m;
int A[MAX_VERTICES][MAX_VERTICES];
}Graph;
void init_graph(Graph *G,int n){
G->n = n;
int i,j;
for(i=1; i<=n; i++)
for(j=0; j<n; j++)
G->A[i][j]=0;
}
void add_edge(Graph *G,int x, int y, int w){
G->A[x][y]+=w;
G->A[y][x]+=w;
}
void swap(Edge *a, Edge *b){
Edge t;
t=*a;
*a=*b;
*b=t;
}
int nho_hon(Edge a, Edge b){
if((a.u<b.u) || (a.u==b.u) || (a.v<b.v))
return 1;
return 0;
}
void bubble_sort(Edge e[], int n){
int i,j;
for(i=0; i<=n-1; i++)
for(j=n-1; j>i; j--)
if(nho_hon(e[j], e[j-1]))
swap(&e[j], &e[j-1]);
}
typedef struct{
int data[MAX_LENGTH];
int size;
}List;
void make_null_list(List* L){
L->size = 0;
}
int empty_list(List L){
return L.size==0;
}
void push_back(List* L, int x){
L->data[L->size] = x;
L->size++;
}
int element_at(List* L, int i){
return L->data[i-1];
}
int distancefrom(int u, List L, Graph G){
int min_dist = 9999;
int min_v = -1;
int i;
for(i=1; i<=L.size; i++){
int v = element_at(&L,i);
if(G.A[u][v]!=0 && min_dist>G.A[u][v]){
min_dist=G.A[u][v];
min_v=v;
}
}
return min_v;
}
int check(List L, int x){
int i;
for(i=1; i<=L.size; i++)
if(x==element_at(&L,i))
return 1;
return 0;
}
Edge edges[100];
int dem=0;
int mark[100];
int prim(Graph G, Graph T){

init_graph(&T, G.n);
List L;
make_null_list(&L);
int u,i,sum_w=0;
for(i=1; i<G.n; i++)
mark[i] = 0;
push_back(&L,1);
mark[1] = 1;
for(i=1; i<G.n; i++){
int min_dist=9999, min_u, min_v;
for(u=1; u<=G.n; u++)
if(mark[u]==0){
int v = distancefrom(u,L,G);
if(v!=-1 && G.A[u][v]<min_dist){
min_dist = G.A[u][v];
min_u = u;
min_v = v;
edges[dem].u = v;
edges[dem].v = u;
edges[dem].w = min_dist;
dem++;
}
}
push_back(&L, min_u);
mark[min_u]=1;
add_edge(&T, min_u, min_v, min_dist);
sum_w += min_dist;
}
return sum_w;
}
int main(){
Graph G,T;
int e,n,m,u,v,w,i;
//freopen("dothi.txt","r",stdin);
scanf("%d%d", &n, &m);
init_graph(&G,n);
for(e=0; e<m; e++){
scanf("%d%d%d", &u, &v, &w);
add_edge(&G,u,v,w);}
int sum_w = prim(G,T);
printf("%d", sum_w);
bubble_sort(edges, dem);
for(i=0; i<dem; i++)
printf("%d\n %d\n %d\n", edges[i].u, edges[i].v, edges[i].w);
return 0;
}
